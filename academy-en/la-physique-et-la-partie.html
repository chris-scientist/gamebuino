<!doctype html>
<html lang="en">
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <title>La physique et la partie - Gamebuino</title> 
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous"> 
  <link href="https://fonts.googleapis.com/css?family=Lato|Open+Sans:300,400,600,700,800|Roboto+Mono:300,400,700" rel="stylesheet"> 
  <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-LRlmVvLKVApDVGuspQFnRQJjkv0P7/YFrw84YYQtmYG4nK8c+M+NlmYDCv0rKWpG" crossorigin="anonymous"> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"> 
  <link href="../css/animate.css" rel="stylesheet" type="text/css"> 
  <link href="../css/generic.css" rel="stylesheet" type="text/css"> 
  <link href="../css/jquery-ui.min.css" rel="stylesheet" type="text/css"> 
  <link href="../css/jquery-ui-timepicker-addon.css" rel="stylesheet" type="text/css"> 
  <link href="../css/alertify.core.css" rel="stylesheet" type="text/css"> 
  <link href="../css/alertify.default.css" rel="stylesheet" type="text/css"> 
  <link href="../css/select2.min.css" rel="stylesheet" type="text/css"> 
  <link href="../css/app.css" rel="stylesheet" type="text/css"> 
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script> 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script> 
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script> 
  <script src="../js/jquery.cookie.js" type="text/javascript"></script> 
  <script src="../js/alertify.min.js" type="text/javascript" async></script> 
  <script src="../js/modal.js" type="text/javascript" async></script> 
  <script src="../js/popupConfirm.js" type="text/javascript" async></script> 
  <script src="../js/select2.min.js" type="text/javascript" async></script> 
  <script src="../js/imagesloaded.pkgd.min.js" type="text/javascript" async></script> 
  <script src="../js/wow.min.js" type="text/javascript" async></script> 
  <script src="../js/app.js" type="text/javascript" async></script> 
  <script id="js_highlight" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" async></script> 
  <script>js_highlight.addEventListener('load',function(){$('div.code, pre').each(function(i,block){hljs.highlightBlock(block);});});</script> 
  <link href="https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300,700&amp;display=swap" rel="stylesheet"> 
 </head> 
 <body> 
  <div class="topbar-container w-100 m-0"> 
   <nav class="primary-navbar"> 
    <div id="root-logo"> <a href="/gamebuino/"> <img width="233" src="../assets/gamebuino-logo-white.svg" alt="Gamebuino" class="logo-white"> </a> 
    </div> 
    <ul class="nav nav-pills"> 
     <li class="text-uppercase"> <a href="/gamebuino/meta-api-reference-en/"> META API Reference</a></li> 
     <li class="text-uppercase"> <a href="/gamebuino/academy-en/"> Academy (EN)</a></li> 
    </ul> 
   </nav> 
   <div class="container" id="main-content">
    <div class="container"> 
     <div class="d-flex align-items-center"> <a href="/gamebuino/academy-en/index.html"> Academy </a> 
      <div class="ml-3 mr-3"> <i class="fal fa-angle-right"></i> 
      </div> <a href="/gamebuino/academy-en/sokoban-vs-poo.html"> Apprenez la programmation orient√©e objet avec Sokoban </a> 
      <div class="ml-3 mr-3"> <i class="fal fa-angle-right"></i> 
      </div> <span> La physique et la partie </span> 
     </div> 
    </div> 
    <div class="alert alert-warning mb-3">
      This content is not fully available in your language üòï
    </div> 
    <div class="row"> 
     <div class="col-md-8"> 
      <div class="d-flex justify-content-between"> 
       <div> 
        <h1> La physique et la partie </h1> 
        <h5> Step 5 </h5> 
       </div> 
      </div> 
      <div class="mt-5 white-container"> 
       <div class="lesson-introduction"> 
        <p>Nous allons voir dans cette cinqui√®me et derni√®re √©tape la gestion de la physique et la gestion de la partie, ainsi √† la fin de cette √©tape nous serons en mesure de faire d√©placer une caisse par le personnage, de s'arr√™ter face √† un mur et de d√©terminer si la partie est termin√©e.</p> 
       </div> 
       <div class="lesson-content mt-5"> 
        <h2>Introduction</h2> 
        <p>Les <strong>pr√©-requis</strong> de cette √©tape sont :</p> 
        <ul> 
         <li>Avoir r√©aliser l'√©tape 1, l'√©tape 2, l'√©tape 3 et l'√©tape 4 de ce workshop.</li> 
        </ul> 
        <p>Je vous invite √† t√©l√©charger <a href="https://github.com/chris-scientist/gb-poo/archive/v4.0.0.zip" >le code</a> qui est le r√©sultat de la quatri√®me √©tape, ceci pour partir sur des bases communes.</p> 
        <h2>La physique : collision avec les murs</h2> 
        <p>Il faut pouvoir rester bloqu√© si l'on cherche √† franchir un mur, sachez qu'il s'agit de l'affaire de quelques lignes et que tout ce passe dans CharacterController.</p> 
        <p>D'abord, nous allons √©crire la m√©thode pour d√©tecter que le sprites (que nous nommerons aReplacedSprites) est un mur, il s'agit de la m√©thode isWall, voici le pseudo code :</p> 
        <pre><code>SI aReplacedSprites = mur ALORS
  Retourner vrai
SINON
  Retourner faux
FIN SI
</code></pre> 
        <p>Ceci dit ce pseudo code peut-√™tre optimis√©, en effet la condition renvoye vrai ou faux, le pseudo code est ainsi :</p> 
        <pre><code>Retourner (aReplacedSprites = mur)
</code></pre> 
        <p>Voici le code de la m√©thode :</p> 
        <pre><code>const bool CharacterController::isWall(const char aReplacedSprites) const {
  return (aReplacedSprites == TypeOfSprites::WALL_TYPE);
}
</code></pre> 
        <p>Enfin nous avons plus qu'√† interdire le d√©placement si le sprite est un mur. Rappelez-vous du pseudo code du d√©placement vers le haut par exemple, qui √©tait le suivant :</p> 
        <pre><code>Calculer la position fictive relative √† un d√©placement vers le haut
R√©cup√©rer le sprites relatif √† la position fictive
SI nous sommes toujours sur la carte avec la position fictive ALORS
  Ecraser la position fictive avec la tuile correspondant au joueur
  Remplacer l'ancienne position du joueur par le sprites qui s'y trouvait avant
  Stocker le sprites relatif √† la position fictive
  Mettre √† jour la position du personnage
SINON
  R√©intialiser la position fictive
FIN SI
</code></pre> 
        <p>Voici le pseudo code d'un d√©placement vers le haut qui interdit de franchir un mur :</p> 
        <pre><code>Calculer la position fictive relative √† un d√©placement vers le haut
R√©cup√©rer le sprites relatif √† la position fictive
SI nous sommes toujours sur la carte avec la position fictive ET le sprites o√π nous voulons aller n'est pas un mur ALORS
  Ecraser la position fictive avec la tuile correspondant au joueur
  Remplacer l'ancienne position du joueur par le sprites qui s'y trouvait avant
  Stocker le sprites relatif √† la position fictive
  Mettre √† jour la position du personnage
SINON
  R√©intialiser la position fictive
FIN SI
</code></pre> 
        <p>Voici le code du d√©placement vers le haut avec la contrainte relative au franchissement de mur :</p> 
        <pre><code>void CharacterController::goUp() {
  // calcul de la nouvelle position
  character-&gt;goUp();
  // r√©cup√©rer la tuile de la nouvelle position
  char newTypeOfSprites = mapModel-&gt;getTypeOfSprites(character-&gt;getNextPos()[0], character-&gt;getNextPos()[1]);
  // si la nouvelle position du personnage est sur la carte et que ce n'est pas un mur
  if(character-&gt;getNextPos()[1] &gt;= 0 &amp;&amp; !isWall(newTypeOfSprites)) {
    // √©craser nouvelle position par la tuile du joueur
    mapModel-&gt;setTypeOfSprites(character-&gt;getNextPos()[0], character-&gt;getNextPos()[1], getPlayerSprites(newTypeOfSprites));
    // remplacer ancienne position par la tuile qui √©tait √† cette position pr√©c√©dement
    mapModel-&gt;setTypeOfSprites(character-&gt;getX(), character-&gt;getY(), character-&gt;getOldTypeOfSprites());
    // stocker la tuile de la nouvelle position
    character-&gt;setOldTypeOfSprites(newTypeOfSprites);
    // mettre √† jour la position
    character-&gt;updatePositions();
  } else {
    // remettre √† z√©ro la position suivante
    character-&gt;resetNextPositions();
  }
}
</code></pre> 
        <p>Ajouter la contrainte aux autres d√©placements et le tour sera jou√©.</p> 
        <h2>La physique : d√©placer une caisse</h2> 
        <p>Nous allons maintenant voir le d√©placement d'une caisse, sachez que c'est plus complexe que la contrainte pr√©c√©dente, mais je suis l√† pour vous guider. Et comme la contrainte pr√©c√©dente tout ce joue dans CharacterController.</p> 
        <p>Commen√ßons par √©crire le pseudo code de d√©tection d'une caisse, pensez √† la simplification utilis√© lors de la d√©tection de mur :</p> 
        <pre><code>Retourner (aReplacedSprites = caisse) || (aReplacedSprites = caisse sur zone de 'chargement')
</code></pre> 
        <p>Voici le code de la m√©thode isBox :</p> 
        <pre><code>const bool CharacterController::isBox(const char aReplacedSprites) const {
  return (aReplacedSprites == TypeOfSprites::BOX_TYPE) || 
    (aReplacedSprites == TypeOfSprites::BOX_ON_ZONE_TYPE);
}
</code></pre> 
        <p>Ecrivons un gros morceau, soit le pseudo code pour d√©placer une caisse, il s'agit de la m√©thode moveBox. Les param√®tres de cette m√©thode sont le sprites √† remplacer (aReplacedSprites), les coordonn√©es X1, Y1 ainsi que les coordonn√©es X2, Y2 ces derni√®res repr√©sentent le sprite apr√®s la caisse. Voici le pseudo code :</p> 
        <pre><code>R√©cup√©rer le sprites ayant pour coordonn√©es X2, Y2
Affecter √† stopMove la valeur du test suivant : est diff√©rent du sol ou diff√©rent d'une zone de chargement
SI stopMove est faux ALORS
  SI le sprites de coordonn√©es X2, Y2 est une zone de chargement ALORS
    Affecter √† replacedSprites2 un sprite de type caisse sur zone de chargement
  SINON
    Affecter √† replacedSprites2 un sprite de type caisse
  FIN SI
  Ecraser la position X2, Y2 par replacedSprites2
  SI aReplacedSprites = caisse sur zone de chargement ALORS
    Retourner sprites de type zone de chargement
  SINON
    Retourner sprites de type sol
  FIN SI
FIN SI
Retourner aReplacedSprites
</code></pre> 
        <p>Nous pouvons simplifier le code √† l'aide d'une condition particuli√®re que l'on appelle condition ternaire. Voyons comment faire sur un exemple de pseudo code :</p> 
        <pre><code>SI nb &gt; 0 ALORS
  Affecter √† signe la valeur '+'
SINON
  Affecter √† signe la valeur '-'
FIN SI
</code></pre> 
        <p>Voici le code relatif √† cette exemple, utilisant une condition ternaire :</p> 
        <pre><code>char signe = (nb &gt; 0) ? '+' : '-';
</code></pre> 
        <p>Je vous ai donner cette simplification car nous pouvons l'utiliser √† deux reprises dans le code de moveBox que voici :</p> 
        <pre><code>const char CharacterController::moveBox(const char aReplacedSprites, const int aX1, const int aY1, const int aX2, const int aY2) {
  // on r√©cup√®re le sprites en X2, Y2
  const char sprites = mapModel-&gt;getTypeOfSprites(aX2, aY2);
  // si c'est le sol ou une zone de chargement alors on d√©place la caisse
  stopMove = !((sprites == TypeOfSprites::FLOOR_TYPE) || (sprites == TypeOfSprites::DESTINATION_TYPE));
  if(!stopMove) {
    // on calcul le sprites X2, Y2
    const char replacedSprites2 = (sprites == TypeOfSprites::DESTINATION_TYPE) ? TypeOfSprites::BOX_ON_ZONE_TYPE : TypeOfSprites::BOX_TYPE ;
    // on affecte le sprites X2, Y2
    mapModel-&gt;setTypeOfSprites(aX2, aY2, replacedSprites2);
    return (aReplacedSprites == TypeOfSprites::BOX_ON_ZONE_TYPE) ? TypeOfSprites::DESTINATION_TYPE : TypeOfSprites::FLOOR_TYPE;
  }
  return aReplacedSprites;
}
</code></pre> 
        <p>Remarque : une optimisation est facultative mais possible, en effet nous n'avons pas besoin du couple de coordonn√©es X1, Y1, il peut donc √™tre supprimer. Il s'agit d'une erreur de ma part, j'ai oubli√© de le supprimer d√®s l'√©tape 1 de ce workshop.</p> 
        <p>Il nous reste plus qu'√† connecter les deux m√©thodes que l'on vient d'√©crire au d√©placement. Nous allons nous servir du d√©placement vers le haut pour notre exemple, voici le pseudo code avec la contrainte de d√©placement d'une caisse :</p> 
        <pre><code>Calculer la position fictive relative √† un d√©placement vers le haut
R√©cup√©rer le sprites relatif √† la position fictive
SI nous sommes toujours sur la carte avec la position fictive ET le sprites o√π nous voulons aller n'est pas un mur ALORS
  SI le sprites relatif √† la position fictive est une caisse ALORS
    Faire un appel √† la m√©thode de d√©placement d'une caisse et affecter la valeur de retour au sprites relatif √† la position fictive
  SINON
    Affecter √† stopMove la valeur false
  FIN SI
      
  SI stopMove est faux ALORS
    Ecraser la position fictive avec la tuile correspondant au joueur
    Remplacer l'ancienne position du joueur par le sprites qui s'y trouvait avant
    Stocker le sprites relatif √† la position fictive
    Mettre √† jour la position du personnage
  SINON
    R√©intialiser la position fictive
  FIN SI
SINON
  R√©intialiser la position fictive
FIN SI
</code></pre> 
        <p>Voici le code de la m√©thode goUp modifier avec la contrainte de d√©placement d'une caisse :</p> 
        <pre><code>void CharacterController::goUp() {
  // calcul de la nouvelle position
  character-&gt;goUp();
  // r√©cup√©rer la tuile de la nouvelle position
  char newTypeOfSprites = mapModel-&gt;getTypeOfSprites(character-&gt;getNextPos()[0], character-&gt;getNextPos()[1]);
  // si la nouvelle position du personnage est sur la carte et que ce n'est pas un mur
  if(character-&gt;getNextPos()[1] &gt;= 0 &amp;&amp; !isWall(newTypeOfSprites)) {
    // d√©placer une caisse
    if(isBox(newTypeOfSprites)) {
      newTypeOfSprites = moveBox(newTypeOfSprites, character-&gt;getNextPos()[0], character-&gt;getNextPos()[1], character-&gt;getNextPos()[0], character-&gt;getNextPos()[1] - 1);
    } else {
      stopMove = false;
    }

    if(!stopMove) {
      // √©craser nouvelle position par la tuile du joueur
      mapModel-&gt;setTypeOfSprites(character-&gt;getNextPos()[0], character-&gt;getNextPos()[1], getPlayerSprites(newTypeOfSprites));
      // remplacer ancienne position par la tuile qui √©tait √† cette position pr√©c√©dement
      mapModel-&gt;setTypeOfSprites(character-&gt;getX(), character-&gt;getY(), character-&gt;getOldTypeOfSprites());
      // stocker la tuile de la nouvelle position
      character-&gt;setOldTypeOfSprites(newTypeOfSprites);
      // mettre √† jour la position
      character-&gt;updatePositions();
     } else {
        character-&gt;resetNextPositions();
     }
    } else {
      // remettre √† z√©ro la position suivante
      character-&gt;resetNextPositions();
    }
}
</code></pre> 
        <p>Le code pour les autres directions est similaire, √† l'exception des coordonn√©es X2, Y2 pass√© √† moveBox qu'il faut adapter, voyons cela.</p> 
        <p><strong>Aller vers la droite</strong></p> 
        <pre><code>X2 = character-&gt;getNextPos()[0] + 1
Y2 = character-&gt;getNextPos()[1]
</code></pre> 
        <p><strong>Aller vers le bas</strong></p> 
        <pre><code>X2 = character-&gt;getNextPos()[0]
Y2 = character-&gt;getNextPos()[1] + 1
</code></pre> 
        <p><strong>Aller vers la gauche</strong></p> 
        <pre><code>X2 = character-&gt;getNextPos()[0] - 1
Y2 = character-&gt;getNextPos()[1]
</code></pre> 
        <p>Une fois les m√©thodes compl√©t√©es, amusez vous avec le jeu, en effet vous devriez √™tre en mesure de d√©placer les caisses sur les zones de chargement.</p> 
        <h2>GESTION DE LA PARTIE</h2> 
        <p>Dans ce dernier chapitre du workshop nous allons aborder la gestion de la fin de partie. Effectivement il serait bien de f√©liciter le joueur lorsque celui-ci √† d√©placer l'ensemble des caisses sur les zones de chargement.</p> 
        <p>Pour cela il faut parcourir la carte, la m√©thode isFinish de MapModel nous indique si le jeu est termin√©e ou non (via isEnd), voici le pseudo code :</p> 
        <pre><code>Affecter √† isEnd la valeur true
PARCOURIR la carte sur l'axe Y tant que le jeu est termin√©
  PARCOURIR la carte sur l'axe X tant que le jeu est termin√©
    Affecter √† isEnd la valeur de isEnd ET (sprites X, Y diff√©rent de zone de chargement ET sprites X, Y diff√©rent de caisse)
  FIN PARCOURIR
FIN PARCOURIR
Retourner isEnd
</code></pre> 
        <p>Voici le code de la m√©thode :</p> 
        <pre><code>bool MapModel::isFinish() const {
  bool isEnd = true;
  for(int y=0 ; y &lt; HEIGHT_MAP &amp;&amp; isEnd ; y++) {
    for(int x=0 ; x &lt; WIDTH_MAP &amp;&amp; isEnd ; x++) {
      isEnd = isEnd &amp;&amp; !(mapOfGame[y][x] == TypeOfSprites::DESTINATION_TYPE || mapOfGame[y][x] == TypeOfSprites::BOX_TYPE);
    }
  }
  return isEnd;
}
</code></pre> 
        <p>Il faut maintenant que le contr√¥leur ai acc√®s √† isFinish, on rend cela possible via la m√©thode isEndOfGame de MapController que voici:</p> 
        <pre><code>bool MapController::isEndOfGame() const {
  return model-&gt;isFinish();
}
</code></pre> 
        <p>Modifions la m√©thode run de MainController pour que lorsque la partie est finie on affiche un √©cran "Gagn√©", soit le code suivant :</p> 
        <pre><code>void MainController::run() {
  if(! mapController-&gt;isEndOfGame()) {
    characterController-&gt;run();
    const int* cameraPos = cameraModel-&gt;getCameraPositions(characterController-&gt;getX(), characterController-&gt;getY());
    mapController-&gt;paint(cameraPos);
  } else {
    gb.display.setFontSize(2);
    gb.display.setColor(BROWN);
    gb.display.println("");
    gb.display.println("");
    gb.display.println("  Gagne");
  }
}
</code></pre> 
        <p>Votre jeu est maintenant compl√©tement jouable, amusez vous bien !</p> 
        <h2>CONCLUSION</h2> 
        <p>Cette √©tape √©tait la derni√®re du workshop. Vous pouvez t√©l√©charger le <a href="https://github.com/chris-scientist/gb-poo/archive/v5.0.0.zip" >code source final</a>. Le jeu est jouable mais √©galement am√©liorable. En effet il pourrait √™tre int√©ressant de pouvoir recommencer la partie (sans avoir √† quitter le jeu), ou bien avoir plusieurs cartes, etc. Mais le but de ce workshop √©tait de proposer une initiation √† la programmation orient√©e objet et au mod√®le d'architecture Mod√®le Vue Contr√¥leur (MVC), j'esp√®re que ce workshop vous servira dans vos prochaine cr√©ations. Le d√©coupage de ce workshop n'est pas anodin, effectivement nous avons d√©velopper chacune des briques de notre jeu pas √† pas, bloc de fonctionnalit√©s apr√®s bloc, et c'est comme cela que vous devez concevoir vos jeux.</p> 
        <h3>Aller plus loin</h3> 
        <p>Avant de partir, et si vous voulez voir une autre approche du MVC, je vous conseille fortement de lire l'excellent workshop de <span>steph</span> sur le jeu de la vie disponible <a href="https://m1cr0lab-gamebuino.github.io/gb-game-of-life/" >ici</a>. Le workshop pr√©sente le jeu selon diff√©rentes approches : une approche fonctionnelle jusqu'au MVC en passant par une version purement objet. De plus, il a ajout√©, toujours dans ce workshop, des interactions avec les LEDs ainsi que des effets sonores.</p> 
        <p><a href="/gamebuino/academy-en/partagez-votre-projet-sur-github-1.html" title="Partagez votre projet sur GitHub" class="btn btn-primary btn-lg"> Next workshop <i class="fa fa-forward"></i></a></p>
       </div> 
      </div> 
     </div> 
     <div class="col-md-4 d-none d-md-block"> 
      <ul class="workshop-summary-mini"> 
       <li class=""> <a href="/gamebuino/academy-en/les-bases.html" class="d-flex align-items-center  "> 
         <div class="circle">
           1 
         </div> 
         <div class="title ml-3">
           Les bases 
         </div> </a></li> 
       <li class=""> <a href="/gamebuino/academy-en/la-camera.html" class="d-flex align-items-center  "> 
         <div class="circle">
           2 
         </div> 
         <div class="title ml-3">
           La cam√©ra 
         </div> </a></li> 
       <li class=""> <a href="/gamebuino/academy-en/l-affichage.html" class="d-flex align-items-center  "> 
         <div class="circle">
           3 
         </div> 
         <div class="title ml-3">
           L'affichage 
         </div> </a></li> 
       <li class=""> <a href="/gamebuino/academy-en/le-personnage.html" class="d-flex align-items-center  "> 
         <div class="circle">
           4 
         </div> 
         <div class="title ml-3">
           Le personnage 
         </div> </a></li> 
       <li class=""> <a href="/gamebuino/academy-en/la-physique-et-la-partie.html" class="d-flex align-items-center  active  "> 
         <div class="circle">
           5 
         </div> 
         <div class="title ml-3">
           La physique et la partie 
         </div> </a></li> 
      </ul> 
     </div> 
    </div> 
    <div class="d-block d-md-none" style="margin-top:8rem"> 
     <h4 class="mb-4">Steps</h4> 
     <ul class="workshop-summary-mini"> 
      <li class=""> <a href="/gamebuino/academy-en/les-bases.html" class="d-flex align-items-center  "> 
        <div class="circle">
          1 
        </div> 
        <div class="title ml-3">
          Les bases 
        </div> </a></li> 
      <li class=""> <a href="/gamebuino/academy-en/la-camera.html" class="d-flex align-items-center  "> 
        <div class="circle">
          2 
        </div> 
        <div class="title ml-3">
          La cam√©ra 
        </div> </a></li> 
      <li class=""> <a href="/gamebuino/academy-en/l-affichage.html" class="d-flex align-items-center  "> 
        <div class="circle">
          3 
        </div> 
        <div class="title ml-3">
          L'affichage 
        </div> </a></li> 
      <li class=""> <a href="/gamebuino/academy-en/le-personnage.html" class="d-flex align-items-center  "> 
        <div class="circle">
          4 
        </div> 
        <div class="title ml-3">
          Le personnage 
        </div> </a></li> 
      <li class=""> <a href="/gamebuino/academy-en/la-physique-et-la-partie.html" class="d-flex align-items-center  active  "> 
        <div class="circle">
          5 
        </div> 
        <div class="title ml-3">
          La physique et la partie 
        </div> </a></li> 
     </ul> 
    </div>
   </div> 
   <footer id="footer"> 
    <div class="container"> 
     <div class="reinsurance"> 
      <div class="row align-items-center"> 
       <div class="col-sm-3"> 
        <p class="text-left"></p> 
       </div> 
       <div class="col-sm-6"> 
        <p class="text-center">Academy saved on October 8, 2020</p> 
       </div> 
       <div class="col-sm-3"> 
        <p class="text-right"></p> 
       </div> 
      </div> 
     </div> 
     <div class="row"> 
      <div class="col-sm-4 margeur-50"> 
       <ul class=""> 
        <li class="margeur-20"><h5 style="color:white;">Exported by :</h5></li> 
        <li> <a href="https://chris-scientist.github.io">chris-scientist</a></li> 
       </ul> 
      </div> 
      <div class="col-sm-4 margeur-50"> 
       <ul class=""> 
        <li class="margeur-10"> <a href="/gamebuino/why-this-website/">Why this website ?</a></li> 
        <li class="margeur-10"> <a href="/gamebuino/contact/">Contact</a></li> 
       </ul> 
      </div> 
      <div class="col-sm-4 margeur-50"> 
       <h6 class="footer-h6">Exported from official website</h6> 
      </div> 
     </div> 
    </div> 
   </footer>  
  </div>
 </body>
</html>