<!doctype html>
<html lang="en">
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <title>Academy - Gamebuino</title> 
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous"> 
  <link href="https://fonts.googleapis.com/css?family=Lato|Open+Sans:300,400,600,700,800|Roboto+Mono:300,400,700" rel="stylesheet"> 
  <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-LRlmVvLKVApDVGuspQFnRQJjkv0P7/YFrw84YYQtmYG4nK8c+M+NlmYDCv0rKWpG" crossorigin="anonymous"> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"> 
  <link href="../css/animate.css" rel="stylesheet" type="text/css"> 
  <link href="../css/generic.css" rel="stylesheet" type="text/css"> 
  <link href="../css/jquery-ui.min.css" rel="stylesheet" type="text/css"> 
  <link href="../css/jquery-ui-timepicker-addon.css" rel="stylesheet" type="text/css"> 
  <link href="../css/alertify.core.css" rel="stylesheet" type="text/css"> 
  <link href="../css/alertify.default.css" rel="stylesheet" type="text/css"> 
  <link href="../css/select2.min.css" rel="stylesheet" type="text/css"> 
  <link href="../css/app.css" rel="stylesheet" type="text/css"> 
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script> 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script> 
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script> 
  <script src="../js/jquery.cookie.js" type="text/javascript"></script> 
  <script src="../js/alertify.min.js" type="text/javascript" async></script> 
  <script src="../js/modal.js" type="text/javascript" async></script> 
  <script src="../js/popupConfirm.js" type="text/javascript" async></script> 
  <script src="../js/select2.min.js" type="text/javascript" async></script> 
  <script src="../js/imagesloaded.pkgd.min.js" type="text/javascript" async></script> 
  <script src="../js/wow.min.js" type="text/javascript" async></script> 
  <script src="../js/app.js" type="text/javascript" async></script> 
  <script id="js_highlight" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" async></script> 
  <script>js_highlight.addEventListener('load',function(){$('div.code, pre').each(function(i,block){hljs.highlightBlock(block);});});</script> 
  <link href="https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300,700&amp;display=swap" rel="stylesheet"> 
 </head> 
 <body> 
  <div class="topbar-container w-100 m-0"> 
   <nav class="primary-navbar"> 
    <div id="root-logo"> <a href="/gamebuino/"> <img width="233" src="../assets/gamebuino-logo-white.svg" alt="Gamebuino" class="logo-white"> </a> 
    </div> 
    <ul class="nav nav-pills"> 
     <li class="text-uppercase"> <a href="/gamebuino/academy-en/"> Home of Academy (EN)</a></li> 
    </ul> 
   </nav> 
   <div class="container" id="main-content">
    <div class="container"> 
     <div class="d-flex align-items-center"> <a href="gamebuino/academy-en/index.html"> Academy </a> 
      <div class="ml-3 mr-3"> <i class="fal fa-angle-right"></i> 
      </div> <a href="gamebuino/academy-en/sokoban-vs-poo.html"> Apprenez la programmation orient√©e objet avec Sokoban </a> 
      <div class="ml-3 mr-3"> <i class="fal fa-angle-right"></i> 
      </div> <span> Le personnage </span> 
     </div> 
    </div> 
    <div class="alert alert-warning mb-3">
      This content is not fully available in your language üòï You want to contribute? Send us an e-mail at hello@gamebuino.com. 
    </div> 
    <div class="row"> 
     <div class="col-md-8"> 
      <div class="d-flex justify-content-between"> 
       <div> 
        <h1> Le personnage </h1> 
        <h5> Step 4 </h5> 
       </div> 
      </div> 
      <div class="mt-5 white-container"> 
       <div class="lesson-introduction"> 
        <p>Nous allons voir dans cette quatri√®me √©tape la gestion du personnage, ainsi √† la fin de cette √©tape nous serons en mesure de d√©placer le personnage (sans contrainte de physique : on pourra traverser les murs par exemple).</p> 
       </div> 
       <div class="lesson-content mt-5"> 
        <h2>Introduction</h2> 
        <p>Les <strong>pr√©-requis</strong> de cette √©tape sont :</p> 
        <ul> 
         <li>Avoir r√©aliser l'√©tape 1, l'√©tape 2 et l'√©tape 3 de ce workshop.</li> 
        </ul> 
        <p>Je vous invite √† t√©l√©charger <span>le code</span> qui est le r√©sultat de la troisi√®me √©tape, ceci pour partir sur des bases communes.</p> 
        <h2>Cr√©ation des bases</h2> 
        <p>Nous allons dans un premier temps d√©finir toutes les m√©thodes transverses au d√©placement, c'est-√†-dire qu'on utilise quand on se d√©place dans n'importe quelle direction.</p> 
        <p>Nous avons besoin d'un moyen d'agir sur la carte, en effet il va falloir d√©placer le personnage mais aussi remplacer l'ancienne position du personnage par un sprite. Pour ce faire nous allons √©crire un <em>setter</em>, il s'agit d'une m√©thode qui modifie un attribut. Le setter en question est setTypeOfSprites de la classe MapModel, que voici :</p> 
        <pre><code>void MapModel::setTypeOfSprites(const int aXSprites, const int aYSprites, const char aTypeOfSprites) {
  mapOfGame[aYSprites][aXSprites] = aTypeOfSprites;
}
</code></pre> 
        <p>Nous allons maintenant intervenir dans la classe CharacterModel.</p> 
        <p>D'abord, il faut cr√©er le getter sur la nouvelle position soit la m√©thode getNextPos :</p> 
        <pre><code>const int * CharacterModel::getNextPos() const {
  return nextPos;
}
</code></pre> 
        <p>Ensuite, cr√©ons le getter sur l'ancien sprites soit la m√©thode getOldTypeOfSprites :</p> 
        <pre><code>const char CharacterModel::getOldTypeOfSprites() const {
  return oldTypeOfSprites;
}
</code></pre> 
        <p>Cr√©ons le setter sur l'ancien sprites soit la m√©thode setOldTypeOfSprites :</p> 
        <pre><code>void CharacterModel::setOldTypeOfSprites(const char aOldTypeOfSprites) {
  oldTypeOfSprites = aOldTypeOfSprites;
}
</code></pre> 
        <p>Cr√©ons la m√©thode updatePositions, cette m√©thode affecte la position suivante (nextPos) √† la position courante comme ceci :</p> 
        <pre><code>void CharacterModel::updatePositions() {
  x = nextPos[0];
  y = nextPos[1];
}
</code></pre> 
        <p>Enfin cr√©ons la m√©thode resetNextPositions, cette m√©thode r√©initialise la position suivante avec la position courante comme ceci :</p> 
        <pre><code>void CharacterModel::resetNextPositions() {
  nextPos[0] = x;
  nextPos[1] = y;
}
</code></pre> 
        <p>Il reste une derni√ûre m√©thode transverse, en effet il faut calculer le sprites du joueur : s'agit-il du joueur ou du joueur sur une zone de 'chargement' ? Pour le d√©terminer on s'appuie sur le sprites √† remplacer. Voici le pseudo code de la m√©thode getPlayerSprites de CharacterController, on pr√©cise que le sprites √† remplacer se nomme aReplacedSprites :</p> 
        <pre><code>SI aReplacedSprites = zone de chargement OU aReplacedSprites = caisse sur zone de chargement ALORS
  Retourner sprites joueur sur zone de chargement
SINON
  Retourner sprites du joueur
FIN SI
</code></pre> 
        <p>Voici le code correspondant :</p> 
        <pre><code>char CharacterController::getPlayerSprites(const char aReplacedSprites) const {
  if((aReplacedSprites == TypeOfSprites::DESTINATION_TYPE) || (aReplacedSprites == TypeOfSprites::BOX_ON_ZONE_TYPE)) {
    return TypeOfSprites::PLAYER_ON_ZONE_TYPE;
  }
  return TypeOfSprites::PLAYER_TYPE;
}
</code></pre> 
        <p>Nous venons d'√©crire toutes les m√©thodes tranverses au d√©placement.</p> 
        <h2>Se d√©placer vers le haut</h2> 
        <p>D√©placer le personnage vers le haut n√©cessite d'√©crire deux m√©thodes.</p> 
        <p>Dans un premier temps, il faut calculer les coordonn√©es fictives qui correspondent au d√©placement. Pourquoi des coordonn√©es fictives ? Et bien c'est assez simple √† comprendre : imaginez que le personnage est en haut de la carte et qu'il souhaite aller encore plus haut, et bien il faut interdire ce d√©placement et ne pas modifier les coordonn√©es du personnage.</p> 
        <p>Pour aller en haut il faut d√©finir la m√©thode goUp de CharacterModel, pour ce faire on cherche √† modifier la coordonn√©e "y" du personnage comme ceci :</p> 
        <pre><code>void CharacterModel::goUp() {
  nextPos[1] = y - 1;
}
</code></pre> 
        <p>Dans un second temps, il faut √©crire l'ensemble des actions n√©cessaire au d√©placement vers le haut, ceci sera r√©alis√© dans CharacterController et pr√©cis√©ment dans la m√©thode goUp. goUp ? Mais on a d√©j√† une m√©thode de ce nom dans CharacterModel ? C'est vrai, si le C++ n'autorise pas d'√©crire deux fois une fonction avec le m√™me nom (et la m√™me signature), et bien vous pouvez en orient√© objet √©crire la m√©thode x dans la classe A mais √©galement √©crire une m√©thode x dans la classe B et avec la m√™me signature. Voyons le pseudo code de CharacterController::goUp :</p> 
        <pre><code>Calculer la position fictive relative √† un d√©placement vers le haut
R√©cup√©rer le sprites relatif √† la position fictive
SI nous sommes toujours sur la carte avec la position fictive ALORS
  Ecraser la position fictive avec la tuile correspondant au joueur
  Remplacer l'ancienne position du joueur par le sprites qui s'y trouvait avant
  Stocker le sprites relatif √† la position fictive
  Mettre √† jour la position du personnage
SINON
  R√©intialiser la position fictive
FIN SI
</code></pre> 
        <p>Avant de donner la solution le contr√¥le si nous sommes toujours sur la carte est relatif au d√©placement effectu√©, en effet ce ne sera pas le m√™me lorsque nous allons en bas ou dans n'importe quelle autre direction. Le contr√¥le pour un d√©placement vers le haut est le suivant :</p> 
        <pre><code>character-&gt;getNextPos()[1] &gt;= 0
</code></pre> 
        <p>Voici le code de cette m√©thode :</p> 
        <pre><code>void CharacterController::goUp() {
  // calcul de la nouvelle position
  character-&gt;goUp();
  // r√©cup√©rer la tuile de la nouvelle position
  char newTypeOfSprites = mapModel-&gt;getTypeOfSprites(character-&gt;getNextPos()[0], character-&gt;getNextPos()[1]);
  // si la nouvelle position du personnage est sur la carte
  if(character-&gt;getNextPos()[1] &gt;= 0) {
    // √©craser nouvelle position par la tuile du joueur
    mapModel-&gt;setTypeOfSprites(character-&gt;getNextPos()[0], character-&gt;getNextPos()[1], getPlayerSprites(newTypeOfSprites));
    // remplacer ancienne position par la tuile qui √©tait √† cette position pr√©c√©dement
    mapModel-&gt;setTypeOfSprites(character-&gt;getX(), character-&gt;getY(), character-&gt;getOldTypeOfSprites());
    // stocker la tuile de la nouvelle position
    character-&gt;setOldTypeOfSprites(newTypeOfSprites);
    // mettre √† jour la position
    character-&gt;updatePositions();
  } else {
    // remettre √† z√©ro la position suivante
    character-&gt;resetNextPositions();
  }
}
</code></pre> 
        <p>Vous pouvez compiler votre projet et tester... Rien ne se passe quand vous appuez sur la fl√®che du haut !? C'est normal, nous verrons √† la fin de cette √©tape comment animer notre personnage, soyez patient.</p> 
        <h2>Quelques pistes pour les autres d√©placements</h2> 
        <p>Pour les autres direction le principe est le m√™me que pour le d√©placement vers le haut, il faut simplement faire quelques adaptations. Je dresse ici une br√®ve aide afin d'√©crire les autres d√©placements.</p> 
        <p><strong>Aller vers la droite</strong></p> 
        <p>Pour ce faire il faut √©crire la m√©thode CharacterModel::goRight comme ceci :</p> 
        <pre><code>void CharacterModel::goRight() {
  nextPos[0] = x + 1;
}
</code></pre> 
        <p>Puis √©crire la m√©thode CharacterController::goRight √† l'image de goUp, le contr√¥le est cette fois-ci le suivant :</p> 
        <pre><code>character-&gt;getNextPos()[0] &lt; MapModel::WIDTH_MAP
</code></pre> 
        <p><strong>Aller vers le bas</strong></p> 
        <p>Pour ce faire il faut √©crire la m√©thode CharacterModel::goDown comme ceci :</p> 
        <pre><code>void CharacterModel::goDown() {
  nextPos[1] = y + 1;
}
</code></pre> 
        <p>Puis √©crire la m√©thode CharacterController::goDown √† l'image de goUp, le contr√¥le est cette fois-ci le suivant :</p> 
        <pre><code>character-&gt;getNextPos()[1] &lt; MapModel::HEIGHT_MAP
</code></pre> 
        <p><strong>Aller vers la gauche</strong></p> 
        <p>Pour ce faire il faut √©crire la m√©thode CharacterModel::goLeft comme ceci :</p> 
        <pre><code>void CharacterModel::goLeft() {
  nextPos[0] = x - 1;
}
</code></pre> 
        <p>Puis √©crire la m√©thode CharacterController::goLeft √† l'image de goUp, le contr√¥le est cette fois-ci le suivant :</p> 
        <pre><code>character-&gt;getNextPos()[0] &gt;= 0
</code></pre> 
        <h2>Association avec la croix directionnelle</h2> 
        <p>Une fois chaque d√©placement d√©velopp√©, il nous reste √† associer la croix directionnelle √† chaque mouvement. Nous allons pour ce faire d√©finir la m√©thode CharacterController::run.</p> 
        <p>Il faut d√©placer le personnage √† chaque pression sur l'une des fl√®ches ce qui ce traduit par l'utilisation de :</p> 
        <pre><code>gb.buttons.pressed(UN_BOUTON)
</code></pre> 
        <p>Le pseudo code est :</p> 
        <pre><code>SI le joueur appuie sur la fl√®che du haut ALORS
  Aller vers le haut
SINON SI le joueur appuie sur la fl√®che de droite ALORS
  Aller vers la droite
SINON SI le joueur appuie sur la fl√®che du bas ALORS
  Aller vers le bas
SINON SI le joueur appuie sur la fl√®che de gauche ALORS
  Aller vers la gauche
FIN SI
</code></pre> 
        <p>Voici le code :</p> 
        <pre><code>void CharacterController::run() {
  if(gb.buttons.pressed(BUTTON_UP)) {
    goUp();
  } else if(gb.buttons.pressed(BUTTON_RIGHT)) {
    goRight();
  }  else if(gb.buttons.pressed(BUTTON_DOWN)) {
    goDown();
  } else if(gb.buttons.pressed(BUTTON_LEFT)) {
    goLeft();
  }
}
</code></pre> 
        <p>Enfin dans MainController::run il faut faire un appel √† la m√©thode que l'on vient d'√©crire comme ceci :</p> 
        <pre><code>void MainController::run() {
  //gb.display.println("v2.0.0"); // A SUPPRIMER
  //gb.display.printf("Player pos %d,%d", characterController-&gt;getX(), characterController-&gt;getY());
  //gb.display.println("");
  characterController-&gt;run();
  const int* cameraPos = cameraModel-&gt;getCameraPositions(characterController-&gt;getX(), characterController-&gt;getY());
  //gb.display.printf("Cam %d,%d : %d,%d", cameraPos[0], cameraPos[1], cameraPos[2], cameraPos[3]);
  //gb.display.println("");
  mapController-&gt;paint(cameraPos);
}
</code></pre> 
        <p>Notre personnage est maintenant capable de se d√©placer dans les limites de la carte √† l'aide de la croix directionnelle.</p> 
        <p>Si vous avez termin√© ou si vous rencontrez des probl√®mes vous pouvez t√©l√©charger la solution <span>ici</span>.</p> 
        <p>Dans la prochaine √©tape, c'est-√†-dire la cinqui√®me et derni√®re, nous r√©aliserons la gestion de la physique ainsi que la fin de partie.</p> 
        <p>N'h√©sitez pas √† me faire un retour : les am√©liorations que vous apporteriez (un regard ext√©rieur est toujours bienvenu), les fautes, etc.</p> 
       </div> 
      </div> 
     </div> 
     <div class="col-md-4 d-none d-md-block"> 
      <ul class="workshop-summary-mini"> 
       <li class=""> <a href="gamebuino/academy-en/les-bases.html" class="d-flex align-items-center  "> 
         <div class="circle">
           1 
         </div> 
         <div class="title ml-3">
           Les bases 
         </div> </a></li> 
       <li class=""> <a href="gamebuino/academy-en/la-camera.html" class="d-flex align-items-center  "> 
         <div class="circle">
           2 
         </div> 
         <div class="title ml-3">
           La cam√©ra 
         </div> </a></li> 
       <li class=""> <a href="gamebuino/academy-en/l-affichage.html" class="d-flex align-items-center  "> 
         <div class="circle">
           3 
         </div> 
         <div class="title ml-3">
           L'affichage 
         </div> </a></li> 
       <li class=""> <a href="gamebuino/academy-en/le-personnage.html" class="d-flex align-items-center  active  "> 
         <div class="circle">
           4 
         </div> 
         <div class="title ml-3">
           Le personnage 
         </div> </a></li> 
       <li class=""> <a href="gamebuino/academy-en/la-physique-et-la-partie.html" class="d-flex align-items-center  "> 
         <div class="circle">
           5 
         </div> 
         <div class="title ml-3">
           La physique et la partie 
         </div> </a></li> 
      </ul> 
     </div> 
    </div> 
    <div class="d-block d-md-none" style="margin-top:8rem"> 
     <h4 class="mb-4">Steps</h4> 
     <ul class="workshop-summary-mini"> 
      <li class=""> <a href="gamebuino/academy-en/les-bases.html" class="d-flex align-items-center  "> 
        <div class="circle">
          1 
        </div> 
        <div class="title ml-3">
          Les bases 
        </div> </a></li> 
      <li class=""> <a href="gamebuino/academy-en/la-camera.html" class="d-flex align-items-center  "> 
        <div class="circle">
          2 
        </div> 
        <div class="title ml-3">
          La cam√©ra 
        </div> </a></li> 
      <li class=""> <a href="gamebuino/academy-en/l-affichage.html" class="d-flex align-items-center  "> 
        <div class="circle">
          3 
        </div> 
        <div class="title ml-3">
          L'affichage 
        </div> </a></li> 
      <li class=""> <a href="gamebuino/academy-en/le-personnage.html" class="d-flex align-items-center  active  "> 
        <div class="circle">
          4 
        </div> 
        <div class="title ml-3">
          Le personnage 
        </div> </a></li> 
      <li class=""> <a href="gamebuino/academy-en/la-physique-et-la-partie.html" class="d-flex align-items-center  "> 
        <div class="circle">
          5 
        </div> 
        <div class="title ml-3">
          La physique et la partie 
        </div> </a></li> 
     </ul> 
    </div>
   </div> 
   <footer id="footer"> 
    <div class="container"> 
     <div class="reinsurance"> 
      <div class="row align-items-center"> 
       <div class="col-sm-3"> 
        <p class="text-left"></p> 
       </div> 
       <div class="col-sm-6"> 
        <p class="text-center">Academy saved on October 8, 2020</p> 
       </div> 
       <div class="col-sm-3"> 
        <p class="text-right"></p> 
       </div> 
      </div> 
     </div> 
     <div class="row"> 
      <div class="col-sm-4 margeur-50"> 
       <ul class=""> 
        <li class="margeur-20"><h5 style="color:white;">Exported by :</h5></li> 
        <li> <a href="https://chris-scientist.github.io">chris-scientist</a></li> 
       </ul> 
      </div> 
      <div class="col-sm-4 margeur-50"> 
       <ul class=""> 
        <li class="margeur-10"> <a href="/gamebuino/why-this-website/">Why this website ?</a></li> 
        <li class="margeur-10"> <a href="/gamebuino/contact/">Contact</a></li> 
       </ul> 
      </div> 
      <div class="col-sm-4 margeur-50"> 
       <h6 class="footer-h6">Exported from official website</h6> 
      </div> 
     </div> 
    </div> 
   </footer>  
  </div>
 </body>
</html>