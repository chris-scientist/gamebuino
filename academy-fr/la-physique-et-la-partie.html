<!doctype html>
<html lang="fr">
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <title>La physique et la partie - Gamebuino</title> 
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous"> 
  <link href="https://fonts.googleapis.com/css?family=Lato|Open+Sans:300,400,600,700,800|Roboto+Mono:300,400,700" rel="stylesheet"> 
  <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-LRlmVvLKVApDVGuspQFnRQJjkv0P7/YFrw84YYQtmYG4nK8c+M+NlmYDCv0rKWpG" crossorigin="anonymous"> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"> 
  <link href="../css/animate.css" rel="stylesheet" type="text/css"> 
  <link href="../css/generic.css" rel="stylesheet" type="text/css"> 
  <link href="../css/jquery-ui.min.css" rel="stylesheet" type="text/css"> 
  <link href="../css/jquery-ui-timepicker-addon.css" rel="stylesheet" type="text/css"> 
  <link href="../css/alertify.core.css" rel="stylesheet" type="text/css"> 
  <link href="../css/alertify.default.css" rel="stylesheet" type="text/css"> 
  <link href="../css/select2.min.css" rel="stylesheet" type="text/css"> 
  <link href="../css/app.css" rel="stylesheet" type="text/css"> 
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script> 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script> 
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script> 
  <script src="../js/jquery.cookie.js" type="text/javascript"></script> 
  <script src="../js/alertify.min.js" type="text/javascript" async></script> 
  <script src="../js/modal.js" type="text/javascript" async></script> 
  <script src="../js/popupConfirm.js" type="text/javascript" async></script> 
  <script src="../js/select2.min.js" type="text/javascript" async></script> 
  <script src="../js/imagesloaded.pkgd.min.js" type="text/javascript" async></script> 
  <script src="../js/wow.min.js" type="text/javascript" async></script> 
  <script src="../js/app.js" type="text/javascript" async></script> 
  <script id="js_highlight" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" async></script> 
  <script>js_highlight.addEventListener('load',function(){$('div.code, pre').each(function(i,block){hljs.highlightBlock(block);});});</script> 
  <link href="https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300,700&amp;display=swap" rel="stylesheet"> 
 </head> 
 <body> 
  <div class="topbar-container w-100 m-0"> 
   <nav class="primary-navbar"> 
    <div id="root-logo"> <a href="/gamebuino/"> <img width="233" src="../assets/gamebuino-logo-white.svg" alt="Gamebuino" class="logo-white"> </a> 
    </div> 
    <ul class="nav nav-pills"> 
     <li class="text-uppercase"> <a href="/gamebuino/academy-fr/"> Home of Academy (FR)</a></li> 
    </ul> 
   </nav> 
   <div class="container" id="main-content">
    <div class="container"> 
     <div class="d-flex align-items-center"> <a href="/gamebuino/academy-fr/" > Académie </a> 
      <div class="ml-3 mr-3"> <i class="fal fa-angle-right"></i> 
      </div> <a href="/gamebuino/academy-fr/sokoban-vs-poo.html"> Apprenez la programmation orientée objet avec Sokoban </a> 
      <div class="ml-3 mr-3"> <i class="fal fa-angle-right"></i> 
      </div> <span> La physique et la partie </span> 
     </div> 
    </div> 
    <div class="row"> 
     <div class="col-md-8"> 
      <div class="d-flex justify-content-between"> 
       <div> 
        <h1> La physique et la partie </h1> 
        <h5> Étape 5 </h5> 
       </div> 
      </div> 
      <div class="mt-5 white-container"> 
       <div class="lesson-introduction"> 
        <p>Nous allons voir dans cette cinquième et dernière étape la gestion de la physique et la gestion de la partie, ainsi à la fin de cette étape nous serons en mesure de faire déplacer une caisse par le personnage, de s'arrêter face à un mur et de déterminer si la partie est terminée.</p> 
       </div> 
       <div class="lesson-content mt-5"> 
        <h2>Introduction</h2> 
        <p>Les <strong>pré-requis</strong> de cette étape sont :</p> 
        <ul> 
         <li>Avoir réaliser l'étape 1, l'étape 2, l'étape 3 et l'étape 4 de ce workshop.</li> 
        </ul> 
        <p>Je vous invite à télécharger <span>le code</span> qui est le résultat de la quatrième étape, ceci pour partir sur des bases communes.</p> 
        <h2>La physique : collision avec les murs</h2> 
        <p>Il faut pouvoir rester bloqué si l'on cherche à franchir un mur, sachez qu'il s'agit de l'affaire de quelques lignes et que tout ce passe dans CharacterController.</p> 
        <p>D'abord, nous allons écrire la méthode pour détecter que le sprites (que nous nommerons aReplacedSprites) est un mur, il s'agit de la méthode isWall, voici le pseudo code :</p> 
        <pre><code>SI aReplacedSprites = mur ALORS
  Retourner vrai
SINON
  Retourner faux
FIN SI
</code></pre> 
        <p>Ceci dit ce pseudo code peut-être optimisé, en effet la condition renvoye vrai ou faux, le pseudo code est ainsi :</p> 
        <pre><code>Retourner (aReplacedSprites = mur)
</code></pre> 
        <p>Voici le code de la méthode :</p> 
        <pre><code>const bool CharacterController::isWall(const char aReplacedSprites) const {
  return (aReplacedSprites == TypeOfSprites::WALL_TYPE);
}
</code></pre> 
        <p>Enfin nous avons plus qu'à interdire le déplacement si le sprite est un mur. Rappelez-vous du pseudo code du déplacement vers le haut par exemple, qui était le suivant :</p> 
        <pre><code>Calculer la position fictive relative à un déplacement vers le haut
Récupérer le sprites relatif à la position fictive
SI nous sommes toujours sur la carte avec la position fictive ALORS
  Ecraser la position fictive avec la tuile correspondant au joueur
  Remplacer l'ancienne position du joueur par le sprites qui s'y trouvait avant
  Stocker le sprites relatif à la position fictive
  Mettre à jour la position du personnage
SINON
  Réintialiser la position fictive
FIN SI
</code></pre> 
        <p>Voici le pseudo code d'un déplacement vers le haut qui interdit de franchir un mur :</p> 
        <pre><code>Calculer la position fictive relative à un déplacement vers le haut
Récupérer le sprites relatif à la position fictive
SI nous sommes toujours sur la carte avec la position fictive ET le sprites où nous voulons aller n'est pas un mur ALORS
  Ecraser la position fictive avec la tuile correspondant au joueur
  Remplacer l'ancienne position du joueur par le sprites qui s'y trouvait avant
  Stocker le sprites relatif à la position fictive
  Mettre à jour la position du personnage
SINON
  Réintialiser la position fictive
FIN SI
</code></pre> 
        <p>Voici le code du déplacement vers le haut avec la contrainte relative au franchissement de mur :</p> 
        <pre><code>void CharacterController::goUp() {
  // calcul de la nouvelle position
  character-&gt;goUp();
  // récupérer la tuile de la nouvelle position
  char newTypeOfSprites = mapModel-&gt;getTypeOfSprites(character-&gt;getNextPos()[0], character-&gt;getNextPos()[1]);
  // si la nouvelle position du personnage est sur la carte et que ce n'est pas un mur
  if(character-&gt;getNextPos()[1] &gt;= 0 &amp;&amp; !isWall(newTypeOfSprites)) {
    // écraser nouvelle position par la tuile du joueur
    mapModel-&gt;setTypeOfSprites(character-&gt;getNextPos()[0], character-&gt;getNextPos()[1], getPlayerSprites(newTypeOfSprites));
    // remplacer ancienne position par la tuile qui était à cette position précédement
    mapModel-&gt;setTypeOfSprites(character-&gt;getX(), character-&gt;getY(), character-&gt;getOldTypeOfSprites());
    // stocker la tuile de la nouvelle position
    character-&gt;setOldTypeOfSprites(newTypeOfSprites);
    // mettre à jour la position
    character-&gt;updatePositions();
  } else {
    // remettre à zéro la position suivante
    character-&gt;resetNextPositions();
  }
}
</code></pre> 
        <p>Ajouter la contrainte aux autres déplacements et le tour sera joué.</p> 
        <h2>La physique : déplacer une caisse</h2> 
        <p>Nous allons maintenant voir le déplacement d'une caisse, sachez que c'est plus complexe que la contrainte précédente, mais je suis là pour vous guider. Et comme la contrainte précédente tout ce joue dans CharacterController.</p> 
        <p>Commençons par écrire le pseudo code de détection d'une caisse, pensez à la simplification utilisé lors de la détection de mur :</p> 
        <pre><code>Retourner (aReplacedSprites = caisse) || (aReplacedSprites = caisse sur zone de 'chargement')
</code></pre> 
        <p>Voici le code de la méthode isBox :</p> 
        <pre><code>const bool CharacterController::isBox(const char aReplacedSprites) const {
  return (aReplacedSprites == TypeOfSprites::BOX_TYPE) || 
    (aReplacedSprites == TypeOfSprites::BOX_ON_ZONE_TYPE);
}
</code></pre> 
        <p>Ecrivons un gros morceau, soit le pseudo code pour déplacer une caisse, il s'agit de la méthode moveBox. Les paramètres de cette méthode sont le sprites à remplacer (aReplacedSprites), les coordonnées X1, Y1 ainsi que les coordonnées X2, Y2 ces dernières représentent le sprite après la caisse. Voici le pseudo code :</p> 
        <pre><code>Récupérer le sprites ayant pour coordonnées X2, Y2
Affecter à stopMove la valeur du test suivant : est différent du sol ou différent d'une zone de chargement
SI stopMove est faux ALORS
  SI le sprites de coordonnées X2, Y2 est une zone de chargement ALORS
    Affecter à replacedSprites2 un sprite de type caisse sur zone de chargement
  SINON
    Affecter à replacedSprites2 un sprite de type caisse
  FIN SI
  Ecraser la position X2, Y2 par replacedSprites2
  SI aReplacedSprites = caisse sur zone de chargement ALORS
    Retourner sprites de type zone de chargement
  SINON
    Retourner sprites de type sol
  FIN SI
FIN SI
Retourner aReplacedSprites
</code></pre> 
        <p>Nous pouvons simplifier le code à l'aide d'une condition particulière que l'on appelle condition ternaire. Voyons comment faire sur un exemple de pseudo code :</p> 
        <pre><code>SI nb &gt; 0 ALORS
  Affecter à signe la valeur '+'
SINON
  Affecter à signe la valeur '-'
FIN SI
</code></pre> 
        <p>Voici le code relatif à cette exemple, utilisant une condition ternaire :</p> 
        <pre><code>char signe = (nb &gt; 0) ? '+' : '-';
</code></pre> 
        <p>Je vous ai donner cette simplification car nous pouvons l'utiliser à deux reprises dans le code de moveBox que voici :</p> 
        <pre><code>const char CharacterController::moveBox(const char aReplacedSprites, const int aX1, const int aY1, const int aX2, const int aY2) {
  // on récupère le sprites en X2, Y2
  const char sprites = mapModel-&gt;getTypeOfSprites(aX2, aY2);
  // si c'est le sol ou une zone de chargement alors on déplace la caisse
  stopMove = !((sprites == TypeOfSprites::FLOOR_TYPE) || (sprites == TypeOfSprites::DESTINATION_TYPE));
  if(!stopMove) {
    // on calcul le sprites X2, Y2
    const char replacedSprites2 = (sprites == TypeOfSprites::DESTINATION_TYPE) ? TypeOfSprites::BOX_ON_ZONE_TYPE : TypeOfSprites::BOX_TYPE ;
    // on affecte le sprites X2, Y2
    mapModel-&gt;setTypeOfSprites(aX2, aY2, replacedSprites2);
    return (aReplacedSprites == TypeOfSprites::BOX_ON_ZONE_TYPE) ? TypeOfSprites::DESTINATION_TYPE : TypeOfSprites::FLOOR_TYPE;
  }
  return aReplacedSprites;
}
</code></pre> 
        <p>Remarque : une optimisation est facultative mais possible, en effet nous n'avons pas besoin du couple de coordonnées X1, Y1, il peut donc être supprimer. Il s'agit d'une erreur de ma part, j'ai oublié de le supprimer dès l'étape 1 de ce workshop.</p> 
        <p>Il nous reste plus qu'à connecter les deux méthodes que l'on vient d'écrire au déplacement. Nous allons nous servir du déplacement vers le haut pour notre exemple, voici le pseudo code avec la contrainte de déplacement d'une caisse :</p> 
        <pre><code>Calculer la position fictive relative à un déplacement vers le haut
Récupérer le sprites relatif à la position fictive
SI nous sommes toujours sur la carte avec la position fictive ET le sprites où nous voulons aller n'est pas un mur ALORS
  SI le sprites relatif à la position fictive est une caisse ALORS
    Faire un appel à la méthode de déplacement d'une caisse et affecter la valeur de retour au sprites relatif à la position fictive
  SINON
    Affecter à stopMove la valeur false
  FIN SI
      
  SI stopMove est faux ALORS
    Ecraser la position fictive avec la tuile correspondant au joueur
    Remplacer l'ancienne position du joueur par le sprites qui s'y trouvait avant
    Stocker le sprites relatif à la position fictive
    Mettre à jour la position du personnage
  SINON
    Réintialiser la position fictive
  FIN SI
SINON
  Réintialiser la position fictive
FIN SI
</code></pre> 
        <p>Voici le code de la méthode goUp modifier avec la contrainte de déplacement d'une caisse :</p> 
        <pre><code>void CharacterController::goUp() {
  // calcul de la nouvelle position
  character-&gt;goUp();
  // récupérer la tuile de la nouvelle position
  char newTypeOfSprites = mapModel-&gt;getTypeOfSprites(character-&gt;getNextPos()[0], character-&gt;getNextPos()[1]);
  // si la nouvelle position du personnage est sur la carte et que ce n'est pas un mur
  if(character-&gt;getNextPos()[1] &gt;= 0 &amp;&amp; !isWall(newTypeOfSprites)) {
    // déplacer une caisse
    if(isBox(newTypeOfSprites)) {
      newTypeOfSprites = moveBox(newTypeOfSprites, character-&gt;getNextPos()[0], character-&gt;getNextPos()[1], character-&gt;getNextPos()[0], character-&gt;getNextPos()[1] - 1);
    } else {
      stopMove = false;
    }

    if(!stopMove) {
      // écraser nouvelle position par la tuile du joueur
      mapModel-&gt;setTypeOfSprites(character-&gt;getNextPos()[0], character-&gt;getNextPos()[1], getPlayerSprites(newTypeOfSprites));
      // remplacer ancienne position par la tuile qui était à cette position précédement
      mapModel-&gt;setTypeOfSprites(character-&gt;getX(), character-&gt;getY(), character-&gt;getOldTypeOfSprites());
      // stocker la tuile de la nouvelle position
      character-&gt;setOldTypeOfSprites(newTypeOfSprites);
      // mettre à jour la position
      character-&gt;updatePositions();
     } else {
        character-&gt;resetNextPositions();
     }
    } else {
      // remettre à zéro la position suivante
      character-&gt;resetNextPositions();
    }
}
</code></pre> 
        <p>Le code pour les autres directions est similaire, à l'exception des coordonnées X2, Y2 passé à moveBox qu'il faut adapter, voyons cela.</p> 
        <p><strong>Aller vers la droite</strong></p> 
        <pre><code>X2 = character-&gt;getNextPos()[0] + 1
Y2 = character-&gt;getNextPos()[1]
</code></pre> 
        <p><strong>Aller vers le bas</strong></p> 
        <pre><code>X2 = character-&gt;getNextPos()[0]
Y2 = character-&gt;getNextPos()[1] + 1
</code></pre> 
        <p><strong>Aller vers la gauche</strong></p> 
        <pre><code>X2 = character-&gt;getNextPos()[0] - 1
Y2 = character-&gt;getNextPos()[1]
</code></pre> 
        <p>Une fois les méthodes complétées, amusez vous avec le jeu, en effet vous devriez être en mesure de déplacer les caisses sur les zones de chargement.</p> 
        <h2>GESTION DE LA PARTIE</h2> 
        <p>Dans ce dernier chapitre du workshop nous allons aborder la gestion de la fin de partie. Effectivement il serait bien de féliciter le joueur lorsque celui-ci à déplacer l'ensemble des caisses sur les zones de chargement.</p> 
        <p>Pour cela il faut parcourir la carte, la méthode isFinish de MapModel nous indique si le jeu est terminée ou non (via isEnd), voici le pseudo code :</p> 
        <pre><code>Affecter à isEnd la valeur true
PARCOURIR la carte sur l'axe Y tant que le jeu est terminé
  PARCOURIR la carte sur l'axe X tant que le jeu est terminé
    Affecter à isEnd la valeur de isEnd ET (sprites X, Y différent de zone de chargement ET sprites X, Y différent de caisse)
  FIN PARCOURIR
FIN PARCOURIR
Retourner isEnd
</code></pre> 
        <p>Voici le code de la méthode :</p> 
        <pre><code>bool MapModel::isFinish() const {
  bool isEnd = true;
  for(int y=0 ; y &lt; HEIGHT_MAP &amp;&amp; isEnd ; y++) {
    for(int x=0 ; x &lt; WIDTH_MAP &amp;&amp; isEnd ; x++) {
      isEnd = isEnd &amp;&amp; !(mapOfGame[y][x] == TypeOfSprites::DESTINATION_TYPE || mapOfGame[y][x] == TypeOfSprites::BOX_TYPE);
    }
  }
  return isEnd;
}
</code></pre> 
        <p>Il faut maintenant que le contrôleur ai accès à isFinish, on rend cela possible via la méthode isEndOfGame de MapController que voici:</p> 
        <pre><code>bool MapController::isEndOfGame() const {
  return model-&gt;isFinish();
}
</code></pre> 
        <p>Modifions la méthode run de MainController pour que lorsque la partie est finie on affiche un écran "Gagné", soit le code suivant :</p> 
        <pre><code>void MainController::run() {
  if(! mapController-&gt;isEndOfGame()) {
    characterController-&gt;run();
    const int* cameraPos = cameraModel-&gt;getCameraPositions(characterController-&gt;getX(), characterController-&gt;getY());
    mapController-&gt;paint(cameraPos);
  } else {
    gb.display.setFontSize(2);
    gb.display.setColor(BROWN);
    gb.display.println("");
    gb.display.println("");
    gb.display.println("  Gagne");
  }
}
</code></pre> 
        <p>Votre jeu est maintenant complétement jouable, amusez vous bien !</p> 
        <h2>CONCLUSION</h2> 
        <p>Cette étape était la dernière du workshop. Vous pouvez télécharger le <span>code source final</span>. Le jeu est jouable mais également améliorable. En effet il pourrait être intéressant de pouvoir recommencer la partie (sans avoir à quitter le jeu), ou bien avoir plusieurs cartes, etc. Mais le but de ce workshop était de proposer une initiation à la programmation orientée objet et au modèle d'architecture Modèle Vue Contrôleur (MVC), j'espère que ce workshop vous servira dans vos prochaine créations. Le découpage de ce workshop n'est pas anodin, effectivement nous avons développer chacune des briques de notre jeu pas à pas, bloc de fonctionnalités après bloc, et c'est comme cela que vous devez concevoir vos jeux. Enfin comme les autres étapes n'hésitez pas à me donner votre avis.</p> 
        <h3>Aller plus loin</h3> 
        <p>Avant de partir, et si vous voulez voir une autre approche du MVC, je vous conseille fortement de lire l'excellent workshop de <span>steph</span> sur le jeu de la vie disponible <span>ici</span>. Le workshop présente le jeu selon différentes approches : une approche fonctionnelle jusqu'au MVC en passant par une version purement objet. De plus, il a ajouté, toujours dans ce workshop, des interactions avec les LEDs ainsi que des effets sonores.</p> 
        <p><a href="/gamebuino/academy-fr/partagez-votre-projet-sur-github-1.html" title="Partagez votre projet sur GitHub" class="btn btn-primary btn-lg"> Workshop suivant <i class="fa fa-forward"></i></a></p>
       </div> 
      </div> 
     </div> 
     <div class="col-md-4 d-none d-md-block"> 
      <ul class="workshop-summary-mini"> 
       <li class=""> <a href="/gamebuino/academy-fr/les-bases.html" class="d-flex align-items-center  "> 
         <div class="circle">
           1 
         </div> 
         <div class="title ml-3">
           Les bases 
         </div> </a></li> 
       <li class=""> <a href="/gamebuino/academy-fr/la-camera.html" class="d-flex align-items-center  "> 
         <div class="circle">
           2 
         </div> 
         <div class="title ml-3">
           La caméra 
         </div> </a></li> 
       <li class=""> <a href="/gamebuino/academy-fr/l-affichage.html" class="d-flex align-items-center  "> 
         <div class="circle">
           3 
         </div> 
         <div class="title ml-3">
           L'affichage 
         </div> </a></li> 
       <li class=""> <a href="/gamebuino/academy-fr/le-personnage.html" class="d-flex align-items-center  "> 
         <div class="circle">
           4 
         </div> 
         <div class="title ml-3">
           Le personnage 
         </div> </a></li> 
       <li class=""> <a href="/gamebuino/academy-fr/la-physique-et-la-partie.html" class="d-flex align-items-center  active  "> 
         <div class="circle">
           5 
         </div> 
         <div class="title ml-3">
           La physique et la partie 
         </div> </a></li> 
      </ul> 
     </div> 
    </div> 
    <div class="d-block d-md-none" style="margin-top:8rem"> 
     <h4 class="mb-4">Étapes</h4> 
     <ul class="workshop-summary-mini"> 
      <li class=""> <a href="/gamebuino/academy-fr/les-bases.html" class="d-flex align-items-center  "> 
        <div class="circle">
          1 
        </div> 
        <div class="title ml-3">
          Les bases 
        </div> </a></li> 
      <li class=""> <a href="/gamebuino/academy-fr/la-camera.html" class="d-flex align-items-center  "> 
        <div class="circle">
          2 
        </div> 
        <div class="title ml-3">
          La caméra 
        </div> </a></li> 
      <li class=""> <a href="/gamebuino/academy-fr/l-affichage.html" class="d-flex align-items-center  "> 
        <div class="circle">
          3 
        </div> 
        <div class="title ml-3">
          L'affichage 
        </div> </a></li> 
      <li class=""> <a href="/gamebuino/academy-fr/le-personnage.html" class="d-flex align-items-center  "> 
        <div class="circle">
          4 
        </div> 
        <div class="title ml-3">
          Le personnage 
        </div> </a></li> 
      <li class=""> <a href="/gamebuino/academy-fr/la-physique-et-la-partie.html" class="d-flex align-items-center  active  "> 
        <div class="circle">
          5 
        </div> 
        <div class="title ml-3">
          La physique et la partie 
        </div> </a></li> 
     </ul> 
    </div>
   </div> 
   <footer id="footer"> 
    <div class="container"> 
     <div class="reinsurance"> 
      <div class="row align-items-center"> 
       <div class="col-sm-3"> 
        <p class="text-left"></p> 
       </div> 
       <div class="col-sm-6"> 
        <p class="text-center">Academy saved on October 8, 2020</p> 
       </div> 
       <div class="col-sm-3"> 
        <p class="text-right"></p> 
       </div> 
      </div> 
     </div> 
     <div class="row"> 
      <div class="col-sm-4 margeur-50"> 
       <ul class=""> 
        <li class="margeur-20"><h5 style="color:white;">Exported by :</h5></li> 
        <li> <a href="https://chris-scientist.github.io">chris-scientist</a></li> 
       </ul> 
      </div> 
      <div class="col-sm-4 margeur-50"> 
       <ul class=""> 
        <li class="margeur-10"> <a href="/gamebuino/why-this-website/">Why this website ?</a></li> 
        <li class="margeur-10"> <a href="/gamebuino/contact/">Contact</a></li> 
       </ul> 
      </div> 
      <div class="col-sm-4 margeur-50"> 
       <h6 class="footer-h6">Exported from official website</h6> 
      </div> 
     </div> 
    </div> 
   </footer>  
  </div>
 </body>
</html>